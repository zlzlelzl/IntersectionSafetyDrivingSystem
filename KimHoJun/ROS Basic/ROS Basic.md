# 1. 좌표계
- 좌표계란 공간상에서 물체의 위치를 표현하는 쳬계로 목적에 따라 물체의 위치와 자세를 여러 좌표로 표현한다.
    - 직교 좌표계, 원통 좌표계, 구면 좌표계 등 

## - 직교 좌표계
- 직교 좌표계가 우리에게 가장 익숙하고 흔히 쓰는 방법이며, 3개의 축인 x, y, z가 서로 직각을 이루고 3개의 축이 3차원을 표현하는 좌표계다.
    - IMU 센서가 대표적으로 직교 좌표계를 사용

## - 원통 좌표계
- 극 좌표계는 물체의 위치를 반지름과 각도로 표현한다. 반지름은 물체와의 거리를 의미하며, 각도는 기준 각도와 이루는 각을 말한다. 만약 반지름 값이 음의 값을 갖는다면 각도가 가리키는 방향과 반대 방향으로 반지름의 절댓값만큼 떨어진 위치를 말한다.
- 원통 좌표계는 이 극 좌표계에 3차원 공간을 표현하기 위해 평면 극 좌표계에 평면에서부터 높이값을 더해 만들어진 좌표계를 말한다.
    - LiDAR 센서가 대표적으로 원통 좌표계를 사용

## - 구면 좌표계
- 구면 좌표계는 3차원 공간의 위치를 나타내는 좌표계이다.
- 물체의 위치는 원점에서 물체와의 반지름, x 축과 이루는 각도, z 축과 이루는 각도로 표현한다.
- 이 구면 좌표계에서는 x 축과 이루는 각도를 '경도'로 z 축과 이루는 각도를 '위도'로 표현되는 경우도 있다.
    - GPS 센서가 대표적으로 구면 좌표계를 사용

![img01](https://user-images.githubusercontent.com/104968672/223344050-bc02f9d9-e5b8-4766-9c8b-e718c30fb3d1.png)

<hr>

### 좌표계는 하나의 좌표계만을 사용하지 않는 경우도 있다.

<br>

### 디젤 링크(Multil Linkage)의 경우 물체의 운동을 기술하거나 계산할 때 월드 좌표계와 로컬 좌표계를 모두 이용할 수 있다.

![imt02](https://user-images.githubusercontent.com/104968672/223344134-facd672a-6263-4047-ac41-6850e8392dab.png)

### 다음 그림은 같은 구간을 다른 기준 좌표로 사용한 예시
### 왼쪽 그림은 LiDAR 좌표계(로컬 좌표계)로 LiDAR가 바라보고 있는 기준으로 주변을 탐지한다. 차량이 같은 자리, 같은 자세로 있다 하더라도 기준 좌표를 Map 좌표계(월드 좌표계)로 가져가게 되면 오른쪽 그림과 같이 보이게 된다.
### 같은 길임에도 바라보는게(기준) 다르기 때문에 표현이 다르게 될 수 있다.

![img03](https://user-images.githubusercontent.com/104968672/223344185-1172e009-3d87-46fc-ad30-ac8b95a1f552.png)

<br> 

# 2. GPS 좌표계
- GPS 데이터는 위도/경도 데이터를 받아와 지는데 이를 WGS84라고 부른다. WGS는 세계 지구 좌표 시스템이라고 하며 World Geodetic System의 약어입니다. 1984년에 제정되었고 타원체의 중심, 즉 지구의 중심을 원점으로 하고 지구의 회전 축이 Z 축과 평행한 좌표계입니다.
- 위도의 경우 적도를 0도로 기준으로 남쪽과 북극을 나누고 경도의 경우 영국 그리니치 천문대를 기준으로 서쪽과 동쪽으로 구분한다.

![img04](https://user-images.githubusercontent.com/104968672/223344261-01a7cf8d-60c9-42e9-a0fa-9b7734a4d3f6.png)

- WGS84 좌표계는 구 좌표계를 기반으로 자율주행에서 사용될 2D 좌표계 기준 경로 계획 문제를 해결할 수 없다.이때 GPS의 위도, 경도를 평면 좌표계로 변환하여 사용해야 한다.
- 이때 TM 좌표계를 사용하게 되는데 TM 좌표계는 횡축 메르카토르도법을 이용하여서 구성된다.
- 이는 어느 평면을 기준으로 Projection을 어떻게 하는지에 따라서 달라지는데 한국을 기준으로 할 수도 있고, 미국을 기준으로 할 수도 있다. 원점이 어딘지, 어떤 타원체 모델을 사용하는지에 따라 다르게 Projection 된다.
    - 예를 들어 TM 중부 좌표계는 원점이 한반도 어딘가이며 UTM52는 원점이 적도 어딘가입니다. 한반도의 경우 UTM 좌표 상 52번째 Zone에 있기 때문에 UTM52 좌표를 사용해아 한다.

![img05](https://user-images.githubusercontent.com/104968672/223344324-150d04e8-e6ba-4312-b521-08e02624709a.png)

- GPS 센서로부터 받은 WGS84 좌표 기반 데이터를 UTM 좌표로 변환하는 과정을 배울 예정

<br>

# 요약
```
- 직교 좌표계 : IMU 센서
- 원통 좌표계 : LiDAR 센서
- 구면 좌표계 : GPS 센서

- WGS84(World Geodetic System 84) : GPS 데이터(위도/경도 데이터), 지구의 중심을 원점으로 지구의 회전축과 Z 축이 평행한 좌표계

- WGS84 좌표계는 구 좌표계를 기반으로 자율주행에서 사용될 2D 좌표계 기준 경로 계획 문제를 해결할 수 없음 -> TM 좌표계(횡축 메르카토르도법 이용)를 사용해 GPS 데이터(경도/위도 데이터)를 평면 좌표계로 변환하여 사용

- 어느 평면을 기준으로 Projection을 어떻게 하는지에 따라 달라지는데 한국 기준 OR 미국 기준 모두 가능 즉, 어떤 타원체 모델을 사용하는지에 따라 다르게 Projection이 됨

-> GPS 센서로부터 받은 WGS84(위도/경도) 좌표 기반 데이터를 UTM 좌표로 변화하는 과정 학습 필요!
```

<br>

# 3. 물체의 자세
- 물체의 자세는 기준 좌표계에서 물체가 얼마나 회전되어 있는지로 나타냄
- 같은 위치라도 다른 자세를 취할 수 있음

![img06](https://user-images.githubusercontent.com/104968672/223344399-06180f21-efe0-4134-b3b7-0439a005e246.png)

- 이 자세는 오일러 각과 쿼터니언으로 표현할 수 있음
- 오일러 각은 물체의 자세를 3축의 회전 Roll(x), Pitch(y), Yaw(z) 3가지로 표현 가능함
    - 이는 직관적으로 이해하기 쉽지만 몇몇 자세를 표현하지 못하는 '짐벌락 현상'이 존재

    ![img07](https://user-images.githubusercontent.com/104968672/223344466-3cf8340f-5260-4602-ae1d-e27164116e62.png)

    - 오일러 각의 회전은 어떤 축을 먼저 회전 시키냐에 따라 계산 결과가 달라짐

    - 짐벌락 현상은 두 회전축이 겹치는 현상으로 회전축이 겹치게 되면 돌릴 수 있는 축 하나가 사라지기 때문에 문제가 생김

- 이 오일러 각의 짐벌락 현상을 피하기 위해 쿼터니언 타원체 형태로 표현하는 방법이 있음

    - x, y, z, w 변수로 표현하는데 x, y, z는 벡터, w는 스칼라 값을 의미

    - 각 축을 한꺼번에 계산하지 않기 때문에 짐벌락 현상이 발견되지 않아 어떤 회전각이든 계산 가능하고 빠른 연산 처리가 가능

    - 다만 이 쿼터니언 값은 직관적으로 이해하기 어려움이 있음

- 보통 IMU 센서에서 얻은 가속도 데이터를 통해 물체의 자세를 추정하게 되는데, 이때 쿼터니언에서 오일러 각을 변환하거나 오일러에서 쿼터니언으로 변환하는 식을 사용해야 함

-> ROS의 TF 패키지를 사용한다면 위에 있는 수식 없이 손쉽게 변환 가능

<br>

# 요약
```
- 물체의 자세는 기준 좌표계에서 물체가 얼마나 회전되어 있는지 -> 같은 위치라도 다른 자세를 취할 수 있음

- 오일러 각과 쿼터니언으로 표현 가능

1. 오일러 각 : 물체의 자세를 3축의 회전 Roll(x), Pitch(y), Yaw(z) 3가지로 표현 가능 (어떤 축을 먼저 회전 시키냐에 따라 계산 결과가 달라짐) -> 직관적 이해는 쉽지만 몇몇 자세 표현 못함 = 짐벌락 현상(두 회전축이 겹치는 현상으로 회전축이 겹치게 되면 돌릴 수 있는 축 하나가 사라져 문제) -> 쿼터니언 타원체 형태로 표현하는 방법 존재

2. 쿼터니언 : x, y, z는 벡터, w는 스칼라 값을 의미 -> 각 축을 한꺼번에 계산하지 않기 때문에 짐벌락 현상 발생 안함 -> 어떤 회전각이든 계산 가능 & 빠른 연산 처리 가능 -> 직관적으로 이해하기 어려움

- IMU 센서에서 얻은 가속도 데이터로 물체의 자세 추정

    - 오일러 각 -> 쿼터니언 변환
    - 쿼터니언 -> 오일러 각 변환

-> ROS의 TF 패키지로 수직없이 변환 가능
```

<br>

# 4. 정밀도로 지도
- 자율주행 등에 필요한 정보를 3차원으로 제각한 전자 지도
- 크게 3가지 범주를 가지고 있음
    - **차선** : 규제선, 도로 경계선, 정지선, 차로 중심선으로 구성

    - **도로 시설** : 중앙 분리대, 터널, 교량, 지하차도로 구성

    - **표지 시설** : 교통 안전표지, 노편 표시 신호기로 구성

- 해상도는 0.25um 급, 국토지리정보원에서 제작/배포
- 정밀 도로 지도가 m 단위의 오차가 발생하면 사고 유발 가능성 있음

## Example
- 도로의 폭은 2.5m ~ 3.5m 정도로 갖는데, 3m의 도로에 차량이 주행중이라 가정
- 이때 차폭은 1.8m를 갖는 중형 세단이라 가정
- 남은 여유 공간은 0.6m (3m - 1.8m = 1.2m // 2 = 0.6m)가 됨
- 만약 m 단위의 오차가 발생한다면 차량은 다른 차선을 넘어갈 수 있고, 근접해 있는 차선에서 주행하는 차량과 추돌할 수 있는 조건이 됨

![img08](https://user-images.githubusercontent.com/104968672/223344551-1f4058e9-f16c-48de-b07e-421fd91fe57f.png)

- 자율주행 자동차의 성공적인 개발과 적용에 있어 도로 인프라, 차량 간 통신, 센서의 고성능과 저가화 등 갖추어야 할 요소들이 매우 많음
- 특히 최근 들어 고정밀지도의 필요성과 중요성이 크게 부각되고 있음
- 이는 센서가 갖는 기술적 한계를 보완하여 신뢰성 있게 자율주행 자동차를 구동 시키는데 정밀한 위치 정보를 가지고 차량에 미리 입력되어 있는 지도 정보가 필수적이기 때문

    - 예를 들어 LiDAR 센서는 최대 인식거리가 250m에 불과

    - 빠른 속도로 달리고 있는 차량이 250m 앞의 표지판을 제대로 인식하지 못할 경우 이를 피할 수 있는 시간은 단 몇 초에 불과
    
    - 즉, 인식하지 못함을 인지하고 정밀도로 지도를 함께 매칭하여 도로와 주변 상황을 식별한다면 이러한 사고에 대한 위험을 크게 낮출 수 있음 -> 안전이 무엇보다 최우선시 되는 자율주행에 있어 정밀도로 지도는 필수 불가결 존재

    - 센서로 인식한 정보를 도로 정보와 비교하고 센서로 감지하지 못한 정보는 도로 정보로 대체하여 사용하는 것

    - 또한, 자율주행 차량은 다양하나 센서를 통해 도로 상에 많은 데이터를 처리하는데 이 처리하는 데이터 양이 너무 많기 때문에 미리 정밀지도 통해 정보를 어느정도 파악을 하는 용도로 쓰임


<br>

# 요약
```
- 자율주행 등에 필요한 정보를 3차원으로 제각한 전자 지도

- 크게 3가지 범주를 가지고 있음

    1. 차선 : 규제선, 도로 경계선, 정지선, 차로 중심선으로 구성

    2. 도로 시설 : 중앙 분리대, 터널, 교량, 지하차도로 구성

    3.  표지 시설 : 교통 안전표지, 노편 표시 신호기로 구성

- 해상도는 0.25um 급, 국토지리정보원에서 제작/배포

- 정밀 도로 지도가 m 단위의 오차가 발생하면 사고 유발 가능성 있음

-> 정밀도로 지도는 필수 불가결한 존재
```

<br>

# 5. MGeo
- MORAI + Geometry data를 말함

- 시뮬레이터에서 사용되는 정밀지도 포맷

- 실제와 동일한 표면 도로, 표지판, 신호등 등 생성에 사용함

- 차량 주행용 경로를 할 때도 사용

- 정밀지도는 매우 다양한 곳에서 제작되고, 그 포맷이 모두 다름

- 파일 포맷도 같더라도 실제 HDMap을 표현하는 방식임

![img09](https://user-images.githubusercontent.com/104968672/223344627-27b2ea0d-24ab-4029-9fcc-417622578007.png)

- MGeo를 도식화하여 보면 아래 그림과 같음

![img10](https://user-images.githubusercontent.com/104968672/223344682-7bc39782-76d0-4fbf-8db6-708c3e5a0ce4.png)


<br>

## 클래스
```
- 형상을 표현하는 클래스

    - BasePoint : 한 개의 점으로 표현

    - BaseLine : 여러 개의 점이 모인 Line

    - BasePlane : 여러 개의 점이 모여 시작점과 끝을 연결함

- 주행 경로를 표현하기 위한 데이터

    - Node : 서로 다른 두 개 이상의 Link 간의 연결 여부

    - Line : 연결성을 표현할 수 있는 선(단방향) -> Line의 전과 후 Node를 찾음

    - Link : 차량의 주행 경로 -> 좌/우의 Link를 찾을 수 있음 -> 차선 변경이 가능한 Link인지 표현
```

## 노드 / 링크

```
- 노드 정보(Node)

    - 필드

        - Idx : 노드 이름

        - to_links : 노드에서 나가는 링크 리스트

        - from_links : 노드로 들어오는 링크 리스트

        - on_stop_line : 정지선 여부 (True or False)

    - 메소드

        - get_to_links() : 노드에서 나가는 링크 리스트 리턴

        - get_from_linke(): 노드에서 들어오는 링크 리스트 리턴

        - get_to_links_idx_list() : 나가는 링크 아이디 리스트 리턴

        - get_from_links_idx_list() : 들어오는 링크 아이디 리스트 리턴

        - get_from_nodes() : 이전 연결된 노드 리스트 리턴

        - get_to_nodes() : 다음이 될 노드 리스트 리턴

        - print-all_related_nodes_and_links() : 연결된 노드, 링크들 모두 출력

    - 링크 정보 (Link)

        - idx : 링크 이름

        - from_node : 링크 시작 노드

        - to_node : 링크 끝 노드

        - lazy_point_init : 차선 변경 리크 여부

        - lane-change_pair_list : 차선 변경 리크 리스트

        - max_speed_kph : 링크에서 주행할 수 있는 최대 속도

        - min_speed_kph : 링크에서 주행할 수 있는 최저 속도

        - traffic_signs : 신호등에 연결된 신호등

        - traffic_lights : 받아야 하는 신호등 신호

    - 메소드 (Method)

        - get_to_node() : 링크 끝 노드 리턴

        - get_from_node() : 링크 시작 노드 리턴

        - get_to_links() : 나가는 링크 리스트 리턴

        - get_from_links() :  들어오는 링크 리스트 리턴

        - is_it_for_lane_change() : 차선 변경 링크인지 리턴(Ture or False)

        - get_lane_change-pair_list() : 차선 변경할 수 있는 링크 리스트 리턴
        
        - get_number_of_lane_change() : 차선 변경할 수 있는 링크 갯수 리턴
```

# 6. 경로 계획
- 차량이 주행할 경로를 만들어 주는 과정

- 안전한 경로인가, 최적화된 경로인가(cost가 낮은)를 고려해야 함

- 전역 경로 계획(Global Path Planning) 과 지역 경로 계획(Local Path Planning)으로 나눌 수 있음

![img11](https://user-images.githubusercontent.com/104968672/223344784-55e8b9c5-6d84-436f-b308-2286696bbfc1.png)

- 우리가 사용하는 네비게이션에 비유 가능
    - 출발지(현재 지점)에서 목적지(도착 지점)를 찍으면 전체적인 경로가 만들어지는데 이것을 전역(Global) 경로 계획이라 함
    - 주행 도중 실수로 다른 길을 들어가면 새로운 경로를 찾게 됨 -> 전체(Gloal) 경로에서 일부분을 수정해서 주행하는 것을 지역(Local) 경로 게획이라 함

![img12](https://user-images.githubusercontent.com/104968672/223344842-d817458d-7b23-4cd6-89bf-8436661e291d.png)

# 7. Dijkstra
- 그래프에서 노드 간에 최단 경로를 찾는 알고리즘

- 시작 노드부터 다른 모든 노드까지의 최단 경로를 찾는 알고리즘으로 사용됨

- 맵 퀘스트(Map quest)나 구글 맵스(Google Maps)와 같은 웹 서비스에 사용되며, 인공위성 GPS 등의 소프트웨어에 사용됨

- 전체적인 동작과정은 아래와 같음

```
1. 시작 노드를 지정

2. 시작 노드를 기준으로 다른 노드와의 비용을 저장

3. 방문하지 않은 노드들 중에서 가장 적은 비용이 드는 노드부터 방문

4. 방문한 노드와 인접한 노드들을 조사해서 새로 조사된 최단 거리가 발결된 최단 거리보다 짧으면 정보를 갱신

    -> 새로 조사된 최단 거리 : 시작 노드에서 방문 노드까지의 거리 비용 + 방문한 노드에서 인접 노드까지의 거리 비용
    -> 기존에 발견된 최단 거리 : 시작 노드에서부터 인접한 노드까지의 거리 비용

5. 3번과 4번 과정을 반복
```

- 아래아래에 있는 사진에서 검은색 점은 노드, 노란색 링크는 노드를 잇는 경로점들

- 시작점에서 도착점까지의 링크를 다 이어주면 차량이 주행할 경로(파란색)가 됨

![img13](https://user-images.githubusercontent.com/104968672/223344902-937b9d3b-a892-41f4-b8a8-984e137c29b9.png)

# 8. Pure pursuit
- 경로 위의 한 점을 원 호를 그리며 따라가는 방법

- 자동차의 기구학과 전방주시거리(Loog-Ahead-Distance)라는 하나의 파라미터만 가지고 조향각을 간단하게 계산할 수 있어, 자율주행 차량의 경로 추종에 사용되고 있는 대표적인 알고리즘 중 하나

- 실제 자동차 모델(Ackermann geometry)을 단순화 한 Bicycle 모델을 사용

- Bicyclde 모델은 아래 그림과 같이 뒷 바퀴 1개와 조향이 가능한 앞 바퀴 1개를 가지고 있음

![img14](https://user-images.githubusercontent.com/104968672/223345129-e5dc056b-e64b-4e0c-9cc8-d0cde5312a4a.png)

```
L :  차량의 축 거리

R : 조향각(δ)이 주어졌을 때 뒷 바퀴가 이동하는 원의 반지름
```

- R은 아래와 같은 수식으로 유도 가능

![img15](https://user-images.githubusercontent.com/104968672/223345202-72faf321-8c6f-4c56-bfde-920477e3b6e9.png)

![img16](https://user-images.githubusercontent.com/104968672/223345255-f4731805-89cf-4c1d-b3d8-55911cf8ea7b.png)

```
ld : 전방 주시 거리

α = 경로 위의 한 점(g)과 차량과 이루는 각도

-> 경로, 차량의 위치, 축 거리, 전방 주시 거리(ld)가 주어진다면 조향각(δ)을 구할 수 있음
```

- ld는 현재 차량의 속도에 따라 변해야 함
    - 예를 들어 속도가 빠르다면 멀리 보고 운전하고, 속도가 느리다면 가까이 보고  운전하는 것과 같음

<br>

- **적절한 전방 주시 거리(ld)를 찾아 Overshoot(목표점을 넘어가는 )은 줄이고, Saturation Time(목표 도달 시간), Lateral Error(경로 중 차량과 가장 가까운 경로점과 차량과의 직선 거리)를 줄여아 함**

<br>

# 요약
```
- 경로 위의 한 점을 원 호를 그리며 따라가는 방법

- 자동차의 기구학과 전방주시거리(Loog-Ahead-Distance)라는 하나의 파라미터만 가지고 조향각을 간단하게 계산할 수 있어, 자율주행 차량의 경로 추종에 사용되고 있는 대표적인 알고리즘 중 하나

L :  차량의 축 거리

R : 조향각(δ)이 주어졌을 때 뒷 바퀴가 이동하는 원의 반지름

ld : 전방 주시 거리

α = 경로 위의 한 점(g)과 차량과 이루는 각도

- 경로, 차량의 위치, 축 거리, 전방 주시 거리(ld)가 주어진다면 조향각(δ)을 구할 수 있음

-> 적절한 전방 주시 거리(ld)를 찾아 Overshoot(목표점을 넘어가는 )은 줄이고, Saturation Time(목표 도달 시간), Lateral Error(경로 중 차량과 가장 가까운 경로점과 차량과의 직선 거리)를 줄여아 함
```

<br>

# 9. PID
- 원하는 값에 도달하기 위한 기초적인 자동 피드백 제어 방법 중 하나

- 수식이 매우 간단하고, 제어 대상의 모델이 필요하지 않고, 구현 난이도 대비 목표치 추종이나 외란 감쇄 효과에 탁월한 성능을 얻을 수 있어 대부분의 선형 시불변 시스템에서 하용하는 제어기

- 우리가 사용하는 속도 제어기에서는

    - 목표 속도 (목표)

    - 현재 속도 (현재)

    - 목표 속도 - 현재 속도 (오차)

- 오차 값을 가지고 P(비례), I(적분), D(미분)를 통해서 현재의 값을 목표 값으로 수렴시킬 수 있음

- 원하는 성능을 얻기 위해서는 P, I, D 이득 값을 적절히 튜닝하는 과정이 필요

- 적절한 값을 찾지 못하면 시간이 지나도 오차값이 계속 남아있거나 목표하는 값에서 더 멀어져서 시스템이 매우 불안정해질 수 있기 때문에 이득 값을 잘 찾아야 함

- 아래는 P, I, D 이득 값 변화에 따른 반응

![img17](https://user-images.githubusercontent.com/104968672/223345357-40b075f0-95fc-4bfe-9847-131eabffb314.png)

![img18](https://user-images.githubusercontent.com/104968672/223345402-3d79a721-47e8-4122-9095-78223a1f917f.png)

```
비례항(P) : 현재 상태에서 오차 값의 크기에 비례한 제어 작용을 함

적분항(I) : 정상 상태(Steady-State) 오차를 없애는 작용을 함

미분항(D) : 출력 값의 급격한 변화에 제동을 걸어 Overshoot을 줄이고 안정성을 향상시킴
```

- PID의 성능은 주로 아래 4가지의 지표를 가지고 측정

    - Rise Time : 목표 값의 10%에서 90%까지 도달하는데 걸리는 시간

    - Overshoot : 현재 값이 목표 값보다 커졌을 때의 값

    - Setting Time : 목표 값의 5% 이내에 들어갈 떄의 시간

    - Steady-State Error : 정상상태에 도달하고 나서 존재하는 에러

![img19](https://user-images.githubusercontent.com/104968672/223345454-880366a6-2b4f-46dd-8857-6ccca958e321.png)

<br>

# 요약
```
- 원하는 값에 도달하기 위한 기초적인 자동 피드백 제어 방법 중 하나

- 대부분의 선형 시불변 시스템에서 하용하는 제어기

- 우리가 사용하는 속도 제어기에서는 목표속도(목표), 현재속도(현재), 목표속도 - 현재속도 (오차)

- 오차 값을 가지고 P(비례), I(적분), D(미분)를 통해서 현재의 값을 목표 값으로 수렴시킬 수 있음
    
    -> 원하는 성능을 얻기 위해서는 P, I, D 이득 값을 적절히 튜닝하는 과정이 필요

비례항(P) : 현재 상태에서 오차 값의 크기에 비례한 제어 작용을 함

적분항(I) : 정상 상태(Steady-State) 오차를 없애는 작용을 함

미분항(D) : 출력 값의 급격한 변화에 제동을 걸어 Overshoot을 줄이고 안정성을 향상시킴

- PID의 성능은 주로 4가지의 지표를 가지고 측정

    - Rise Time : 목표 값의 10%에서 90%까지 도달하는데 걸리는 시간

    - Overshoot : 현재 값이 목표 값보다 커졌을 때의 값

    - Setting Time : 목표 값의 5% 이내에 들어갈 떄의 시간

    - Steady-State Error : 정상상태에 도달하고 나서 존재하는 에러
```

<br>

# 10. 경로기반 속도 계획
- 경로(경로점)에서 얼마만큼의 속도를 내야 하는가를 계획하는 것

- 차량은 직선에서 비교적 빠른 속도로 주행이 가능하지만, 곡선에서는 빠른 속도로 주행할 수 없음

- 곡선을 주행할 때 구심력의 작용/반작용 힘에 의해 차량은 원심력을 받게 됨

- 이 힘은 회전 반경에 반비례, 속도의 제곱에 비례하기 때문에 속도가 클수록, 회전 반경이 작을수록 차량이 쉽게 전복이 됨

- 경로기반 속도 계획을 통해 차량이 전복되는 것을 방지할 수 있음

![img20](https://user-images.githubusercontent.com/104968672/223345501-a92eb780-f427-4378-ae9e-87094f15d104.png)

- Flat Roadway일 때, 경로의 곡률 반지름(r)을 안다면 아래 수식과 같이 곡선 도로에서의 최대 속도를 알 수 있음

- us는 운동마찰계수로 아스팔트는 0.7 ~ 0.8이지만 시뮬레이터 환경에 맞게 조절해서 사용하는 것을 추천

![img21](https://user-images.githubusercontent.com/104968672/223345528-d7b7269d-f2c0-4ea0-898a-bd15a550e3db.png)

- 곡률 반지름(r)은 여러가지 방법이 많이 있지만, 쉽게 구현할 수 있는 '최소자승법'을 이용해서 구할 수 있음

![img22](https://user-images.githubusercontent.com/104968672/223345552-9a0c7b07-db7f-4839-93fa-c8adf1142098.png)

![img22-1](https://user-images.githubusercontent.com/104968672/223345625-62d0051c-96d3-480f-a89a-36a5b5df5a48.jpg)
- 최소자승법을 사용하면 경로점들을 가지고 경로와 최대한 근사한 모델(원의 방정식 또는 3차 방정)을 만드는 것

- 곡률 반지름(r)은 원의 방정식이나 3차 방정식을 통해 구할 수 있음

- 원의 방정식을 예로들어 설명하면

![img23](https://user-images.githubusercontent.com/104968672/223345675-10df0380-6fd4-47c4-a4a9-d1a90fdaf572.png)

1. (a, b)가 원점이고, 반지름이 r인 원이 있는데 이 식을 a, b, c에 대해서 정리

![img24](https://user-images.githubusercontent.com/104968672/223345714-e3b4fd9d-b8f5-4cf2-93cb-a950bda614d0.png)

2. n개의 경로점을 이용해 다음과 같이 행렬을 만듬

![img25](https://user-images.githubusercontent.com/104968672/223345755-2a1d453d-3e4e-41d7-ba77-498786432ba0.png)

- Pseudo Inverse 방법을 이용해서 a, b, c를 구할 수 있고 a, b, c를 구하면 다음과 같이 곡률 반지름(r)을 구할 수 있음

<br>

# 11. ACC (Adaptive Cruise Control)
- 운전자(EgoCar)가 설정한 속도로 주행을 하다가 Lader, LiDAR, Camera 등과 같은 환경인지 센서로 앞 차(LeadCar)를 인지하고 앞 차와의 간격을 유지하는 시스템을 말함

- 아래 소개하는 알고리즘은 고전적인 ACC 모듈로서 수식이 매우 단순함

![img26](https://user-images.githubusercontent.com/104968672/223345782-c443d0e4-f726-4468-8502-ce7fef3ed6b0.png)

- 상대 거리(Relative Distance)가 안전 거리(Safe Distacne)보다 크면 Speed Control 모드, 작다면 Spacing Control 모드

![img27](https://user-images.githubusercontent.com/104968672/223345819-1a9a6634-718b-4bb7-9933-5a147fd1bcc2.png)

- D safe (안전 거리)는 현재 속도에서 time gap의 거리와 defaultSpace를 더한 값

- deaflutSpace는 기본 유지 거리이고, time gap은 판단에서 제어까지 차량을 안전하게 멈추는 시간으로 보통 two-second-rule을 따라 2초로 함

- V rel, D rel은 상대 속도와 상대 거리, gain vel은 속도에 대한 이득 값, gain dis는 거리에 대한 이득 값

- 적절한 이득 값 조절을 통해 앞 차의 급격한 속도 변화에도 D rel이 D safe와 같게 유지하는 것이 목표

- ACC는 앞 차와의 거리 간격 유지뿐만 아니라 보행자, 정지선, 장애물에도 적용할 수 있음

- 정지해있는 장애물은 속도가 0인 자동차와 같다고 생각하면 됨